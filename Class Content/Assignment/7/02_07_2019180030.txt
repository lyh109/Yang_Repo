BT에 대한 조사

BT에 이야기하기 위해서는 유한 상태 기계(Finite State Machines, FSM)에 대해서도 알아야 합니다.
FSM은 특정 유형의 로직을 제공하는데, 이는 상태와 전이로 구성됩니다.
상태는 동시에 실행되는 행동의 집합입니다. 애니메이션, 사운드, 특정 시간 동안의 대기를 예로 들 수 있습니다.
전이는 다른 상태로 이동하기 위한 조건을 말합니다.
게임에서 FSM은 애니메이션 상태를 전환하는 데 사용됩니다. FSM의 예시로는 Unity3D의 메카님 스테이트 머신을 들 수 있습니다.
다른 애니메이션으로 전환되는 로직을 쉽게 작성할 수 있으며, 현재 상태를 보여주기 때문에 비주얼 디버깅도 쉽습니다.
하지만 상태가 많아지면 노드가 매우 복잡해지게 됩니다. 그렇기 때문에 상태를 계층화, 그룹화하는 계층적 유한 상태 기계(Hierarchical Finite State Machines, HFSM)라는 개념이 등장합니다.
HFSM은 FSM들을 그룹화하고 계층화함으로써 특정 문맥을 가진 상태를 재사용할 수 있게 합니다. 현재의 문맥을 파악하기도 쉽습니다.
하지만 HFSM이 어느정도의 확장성을 가지고 있음에도 불구하고 하위 상태를 모듈화하는 기능은 제공하지 않습니다.
특정 상태에서 전이되어야 한다는 조건을 가지고 있기 때문에 같은 상태를 다른 문맥에서 사용할 수 없습니다.
예를 들어, '걷기' 상태가 있다면 이것은 '전투'나 '추적' 상태의 하위 상태가 될 수 있습니다.
HSFM을 사용하면 각 문맥에서의 전이 조건은 다르겠지만, '전투' 상태에 '걷기' 상태를 추가하고 '추적' 상태에 '걷기' 상태를 추가해야 합니다.
그래서 같은 상태를 재작성하지 않고도 다른 목적이나 상황에 따라 상태를 재사용할 수 있도록 하기 위해 행동 트리(Behavior Tree)라는 것이 생겼습니다.
BT는 로직을 캡슐화함으로써 상태의 모듈성을 증가시킵니다. 이것은 HFSM에서도 제공하는 기능이지만, 전이라는 것이 존재하지 않는다는 차이점을 가지고 있습니다.
그래서 상태는 그 자체로서 존재할 수 있습니다.

BT를 구현하기 위해서는 스택이라는 자료구조를 사용합니다.
BT는 태스크 집합으로 구성됩니다. 태스크의 종류는 크게 Action, Composite, Condition, Decorator로 나뉩니다.

Action task는 실제 행동을 표현하는 단말 노드입니다. 항상 true나 false를 반환합니다. Action.Onstart(), Action.Onupdate, Action.OnEnd() 같은 메소드를 가지고 있습니다.
Action.Onupdate()에서 true나 false를 반환하면 Action의 작업이 끝납니다.
스택에 처음 올라갈 때, Onstart()가 불리고, true나 false를 반환하기 전까지 Onupdate()가 불립니다. true나 false가 반환되면 스택에서 빠지면서 OnEnd()가 불립니다.

Composite task는 여러 개의 자식으로 구성된 태스크입니다. 사용되는 Composite으로는 Select, Sequence 등이 있습니다.
이러한 Composite의 핵심 용도는 node의 flow를 제어하는 것입니다. 기본적으로 node의 실행 순서는 위에서 아래로, 왼쪽에서 오른쪽으로 입니다.

Select composite은 자식 노드가 true를 반환할 때까지 자식 노드들을 실행합니다.
Sequence composite은 자식 노드가 false를 반환할 때까지 자식 노드들을 실행합니다.

Conditional Aborts(조건부 취소)는 특정한 Action이 예외적인 조건을 충족하였을 때 Action을 취소시킬 수 있는 방법을 말합니다. 평가를 재활성화 한다고도 합니다.
조건부 취소는 실행 흐름에 영향을 주기 때문에 Composite에 기능이 내장되어 있습니다. 
어떤 변수를 계속 감시하고 있다가, 변수의 값이 바뀌게 되면 지금의 실행 흐름을 취소시키고 자신의 노드로부터 재평가합니다.
Conditional Aborts는 보통 Self, Lower Priority, Both로 이루어집니다.
Self는 자신의 하위에 있는 태스크를 취소시키는 것이고, Lower Priotity는 자신의 오른쪽에 있는 이웃 노드의 흐름을 취소시키는 것입니다. Both는 Self + Lower Priotrity 입니다.

Decoration task는 조건을 의미합니다. Decoration은 하나의 자식만을 가질 수 있습니다. 조건을 만족하면 자신을 실행하고, 조건을 만족하지 못하면 false를 반환합니다.
Decoration이 지정하는 조건을 만족했을 경우의 반환 결과는 자식의 반환 결과에 의존합니다. 자주 사용하는 Decoration에는 Probability, TimeOut, CheckEvent 등이 있습니다.


FSM은 보통 상태가 미리 정의되어 있고, 그 상태에서 해야하는 작업도 미리 정의가 되어있습니다.
A에서 B로 전이를 하려면, 해당 상태 내부에서 바꾸어주어야 하지만, BT의 경우에는 부모 노드 혹은 조상 노드 중의 하나가 알아서 처리를 해줍니다.

가독성 부분에서 비교를 하면, BT는 트리 구조이기 때문에 위에서 아래로 내려오며 읽으면 되지만, FSM은 그럴 수 없습니다.
또한 BT에서는 특정 행동이 이상하다면 손쉽게 관련있는 행동을 찾을 수 있습니다.

유지보수 측면에서 보겠습니다. FSM은 행동을 추가할 때, 공통되는 부분을 복사하고 다른 행동으로의 전이 조건을 설정하는 등 많은 수정을 해야하지만,
BT는 전이 조건 노드를 가져와서 적절한 노드의 자식으로 추가하면 됩니다.
BT는 행동을 삭제할 때, 노드를 그냥 삭제하면 되지만, FSM은 해당 노드와 관련된 모든 노드를 삭제해야 합니다.
BT에서 행동에 대한 수정을 할 때에도 그 조건을 담당하는 노드만 수정하면 됩니다. 전이의 작동 원리를 바꾸려면 전이 담당 노드만 수정하면 되고,
실행 순서를 바꾸고 싶다면 자식 노드의 순서만 바꾸어 주면 됩니다.
이처럼 BT는 FSM에 비해 유지보수 또한 쉽습니다.