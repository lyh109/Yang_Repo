1. git 관련 문서를 찾아 읽고 git에 있는 개념들과 할 수 있는 것들에 대해 정리
git은 프로젝트의 변경을 관리하는 버전관리 소프트웨어입니다. 만약 여러 사람이 동시에 같은 자료를 변경하고 업로드하면, 누군가의 작업은 덮어쓰기 되어 사라질 수도 있습니다.
그것을 방지하기 위해 git을 사용합니다. git은 각 사람이 올린 데이터를 같은 페이지에 각각 업로드하고, 사본을 저장하여 변경사항들을 한번에 병합할 수 있게 도와줍니다.
또한 이전의 모든 변경사항을 저장하기 때문에 특정 시점으로 복구할 수 있습니다.
깃허브는 git을 지원하는 서비스 중 가장 유명합니다. 깃허브에서는 다른 사용자들의 프로젝트를 열람할 수 있고, 그것을 변경하거나 배우기 위해서 복사본을 다운로드할 수 있습니다.
깃허브를 사용하기 위해서는 계정을 만들고, 새로운 저장소를 만들면 됩니다. 저장소는 프로젝트가 거주할 수 있는 디렉터리나 저장 공간을 말합니다.
자신의 컴퓨터 안에 있는 로컬 폴더가 될 수도 있고, 깃허브나 다른 온라인 호스트의 저장 공간이 될 수도 있습니다.
git은 커맨드 라인 방식을 이용하여 접근해야 합니다.

커맨드 라인은 깃 명령어를 입력할 때 사용하는 컴퓨터 프로그램입니다. 맥에서는 터미널이라고 합니다.
마우스를 사용하는 것이 아닌, 프롬프트로 알려진 텍스트 기반 명령어를 입력하여 사용합니다.
깃의 주요 명령어는 모두 git으로 시작합니다. git init, git config, git help, git status, git add, git commit, git branch, git checkout, git merge, git push, git pull이 있습니다.
깃을 설치하고 git config 명령어를 이용하여 자신의 이름, 이메일을 입력하여 깃을 설정합니다.
그 다음, 프로젝트가 거주할 온라인 저장소를 만듭니다. 온라인 저장소는 직접적으로 작업하는 공간이 아니므로 로컬 저장소 또한 만들어주어야 합니다.
디렉터리를 만들고, 해당 디렉터리에서 git init을 하여 이 디렉터리가 로컬 깃 저장소임을 컴퓨터에게 알립니다.
그리고 로컬 저장소와 깃허브 저장소를 연결합니다. git remote add origin (주소)를 입력하여 연결할 수 있습니다.
이 과정을 끝내면 git push로 변경사항을 업로드할 수 있습니다. git pull로 깃허브에서 변경사항을 다운로드 할 수도 있습니다.

로컬 저장소는 git이 관리하는 세 가지 나무로 구성되어 있는데, 그 구성원은 작업 디렉터리, 인덱스, 헤드입니다.
작업 디렉터리는 실제 파일들로 이루어져 있고, 인덱스는 준비 영역 역할을 하며, 헤드는 최종 확정본을 나타냅니다.
로컬 저장소를 복제하려면 git clone / 로컬/저장소/경로, 원격 서버의 저장소를 복제하려면 git clone 사용자명@호스트:/원격/저장소/경로 를 입력하면 됩니다.
git status 명령어로 현재 저장소에 있는 내용과 로컬 컴퓨터에 있는 내용이 얼마나 다른지 알아볼 수 있습니다. git add와 commit으로 저장소에 올릴 파일을 최종 확정합니다.
commit 명령어를 통해 몇 개의 파일이 바뀌었는지, 얼마나 수정되었는지 알 수 있습니다. 하지만 이것이 저장소에는 반영되지 않았습니다.
저장소에 반영하기 위해서는 위에서 언급한 git push를 사용합니다.

가지는 안전하게 격리된 상태에서 무언가를 만들 때 사용합니다. 저장소를 새로 만들면 기본으로 master 가지가 만들어집니다.
이 이후에 다른 가지를 이용해 개발을 진행하고, 나중에 개발이 완료되면 master가지로 돌아와 병합하면 됩니다. 이를 가지치기라고 합니다.
git checkout -b로 새로운 가지를 만들어 갈아탈 수 있고, git checkout master 로 master 가지로 돌아올 수 있습니다.
git checkout -d로는 기존의 가지를 삭제할 수 있습니다. 이 가지들을 git push로 원격 저장소에 저장하기 전까지는 다른 사람들이 접근할 수 없습니다.
다른 가지에 있는 변경 내용을 현재 가지에 병합하려면 git merge (가지 이름)을 하면 됩니다. 
만약 병합 도중 충돌이 일어나 실패했다면, 수정 이후 git add (파일 이름) 명령어로 아까의 파일을 병합하게 합니다.
git diff (원래 가지) (비교대상 가지) 명령어로는 병합 이후 어떻게 바뀌었는지 비교해볼 수도 있습니다.

git tag (태그 이름)으로 꼬리표를 달 수 있습니다. git log 명령어로는 확정본 식별자를 얻을 수 있습니다. 
확정본 식별자의 앞부분 일부만 입력해도 꼬리표를 붙일 수 있지만, 그 일부분이 반드시 고유하다는 조건이 필요합니다.4
만약 로컬의 변경 내용을 되돌리고 싶다면 git checkout -- (파일 이름) 명령으로 변경 내용을 되돌릴 수 있습니다.
하지만 이미 인덱스에 추가된 변경 내용과 새로 생성한 파일은 그대로 남습니다.
로컬에 있는 모든 변경 내용과 확정본을 포기하려면, git fetch, git reset --hard 로 원격 저장소의 최신 이력을 가져오고,
로컬 master 가지가 저 이력을 가리키도록 할 수 있습니다.

git의 내장 GUI는 gitk입니다. 콘솔에서 git output을 컬러로 출력하려면 git config color.ui true을 사용합니다.
이력에서 확정본 1개를 한 줄로만 표시하려면 git config format.pretty oneline을 사용합니다.
파일을 추가할 때 대화식으로 추가하려면 git add -i 를 사용합니다.

2. 파이썬 기초(1) 문서를 읽고 코드를 따라 입력해보고, 변형도 해본다.
- 해 본 결과를 입력하고, 느낀 점 기재
연산과 변수를 지정하는 부분, print, 비교연산 등은 C, C++을 사용할 때와 비슷하게 느껴졌습니다.
파이썬으로 코드를 작성할 때 특징 중 하나는 변수의 타입 명을 적어주지 않아도 된다는 것입니다.
근데 type이라는 명령어로 변수의 타입을 알 수 있었습니다. 변수에 저장해준 데이터에 따라 자동으로 타입이 결정되는 것 같습니다.
타입 명을 지정해주지 않고 써도 되니 타이핑 시간을 조금이나마 줄일 수 있어 좋은 것 같다고 생각했습니다.
Str 슬라이드에서 str 변수끼리 더하고, 배열 형태로 한글자씩 볼 수도 있는 것을 알았는데, 인덱스가 음수가 되어도 정상적으로 출력되는 것이 궁금했습니다.
pdf에서는 -2 인덱스까지만 출력했기에 왜 이렇게 나오는지 이해할 수 없었는데, 제 이름을 가진 변수를 만들고 -1 인덱스부터 하나씩 보고 나서
인덱스를 음수로 지정하면 배열의 뒤에서부터 접근한다는 것을 알 수 있었습니다.
>>> first = "YangHui"
>>> last = "Lee"
>>> name = first + " " + last
>>> name[-1]
'e'
>>> name[-2]
'e'
>>> name[-3]
'L'
슬라이스 기법은 (변수 이름)[start:stop:step]으로 할 수 있는데, 필요한 각 요소가 어떻게 쓰이는지 여러가지 입력해본 후 알 수 있었습니다.
step은 기본적으로 1로 값이 고정되고, 변경시키면 그 값만큼 건너뛰어 문자를 출력함을 알았습니다. C 혹은 C++로 했다면 이렇게 출력하기 위해
반복문에다 if문을 추가하여 코드를 작성했을 것 같은데 이렇게 하니 매우 편리하다고 느껴졌습니다.
>>> title = "Python 2D Game Programming"
>>> title[0:6:3]
'Ph'
>>> title[0:6:1]
'Python'
>>> title[:10]
'Python 2D '
List끼리 '+' 를 사용하여 쉽게 내용을 붙일 수 있다는 것을 알았습니다. 하지만 '-' 로 이용하여 더했던 내용을 삭제할 수는 없음을 알게 되었습니다.
>>> alpha1 = [ 'a', 'b', 'c', 'd']
>>> alpha2 = ['e', 'f', 'g']
>>> alphabet = alpha1 + alpha2
>>> alphabet
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> alphabet = alphabet - alpha2
Traceback (most recent call last):
  File "<pyshell#104>", line 1, in <module>
    alphabet = alphabet - alpha2
TypeError: unsupported operand type(s) for -: 'list' and 'list'
List에 서로 다른 타입의 데이터를 넣어도 상관이 없음을 알게되었습니다. 
C, C++에서는 배열에 같은 자료형의 데이터만을 저장하여 사용했었는데, 파이썬에서는 다양한 타입의 데이터를 묶어 저장할 수 있는 방법이 있어 신기했습니다.
>>> l1 = [1, 'a', 3, "가나다"]
>>> l1
[1, 'a', 3, '가나다']
Dictionary는 값을 언제든 추가하여 넣을 수 있고, 키값과 그 키값이 갖는 데이터 값이 따로 있다는 점에서 
데이터를 저장하는 방식이 제가 알고 있는 자료구조 중 map이랑 비슷한 것 같다고 생각했습니다. 
Tuple은 List와 유사하지만 값을 바꿀 수 없다는 점이 다릅니다. tuple에서도 값을 삭제할 수 있는지 궁금해서 List에서와 똑같이 작성해봤는데 오류가 발생했습니다.
안의 데이터 내용 뿐만 아니라 데이터의 개수 또한 변경이 불가능한 것 같습니다. tuple에 대해 찾아봤는데 안의 데이터 개수를 변경하는 방법은 볼 수 없었습니다.
변경하면 안 되는 값을 저장하여 사용하면 편리할 것 같습니다.
>>> t4 = 1,2,3,4
>>> type(t4)
<class 'tuple'>
>>> del t4 3
SyntaxError: invalid syntax
set은 수학의 집합을 계산할 때와 같은 방식인데, 중복된 값은 저장할 수 없습니다.
그리고 &, | 연산자를 통해 교집합을 찾거나, 집합을 합칠 수 있습니다. 수학의 집합이랑 거의 동일하여 이해하기 쉬웠습니다.
>>> s1 = {1,2,3,4}
>>> s2 = {3,4,5,6}
>>> s1 & s2
{3, 4}
>>> s1 | s2
{1, 2, 3, 4, 5, 6}